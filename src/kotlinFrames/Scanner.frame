/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University
with additional support for Kotlin by Henrik Heine

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin
import java.io.IOException
import java.io.InputStream
import java.io.RandomAccessFile
import java.util.*
import kotlin.math.min

class Token {
    var kind = 0 // token kind
    var pos = 0 // token position in bytes in the source text (starting at 0)
    var charPos = 0 // token position in characters in the source text (starting at 0)
    var col = 0 // token column (starting at 1)
    var line = 0 // token line (starting at 1)
    var value = "" // token value
    var next: Token? = null // ML 2005-03-11 Peek tokens are kept in linked list
} //-----------------------------------------------------------------------------------

// Buffer
//-----------------------------------------------------------------------------------
open class Buffer {
    private var buf: ByteArray // input buffer
    private var bufStart = 0 // position of first byte in buffer relative to input stream
    private var bufLen = 0 // length of buffer
    private var fileLen = 0 // length of input stream (may change if stream is no file)
    private var bufPos = 0 // current position in buffer
    private var file: RandomAccessFile? = null // input stream (seekable)
    private var stream: InputStream? = null // growing input stream (e.g.: console, network)

    constructor(s: InputStream?) {
        stream = s
        bufPos = 0
        bufStart = bufPos
        bufLen = bufStart
        fileLen = bufLen
        buf = ByteArray(MIN_BUFFER_LENGTH)
    }

    constructor(fileName: String) {
        try {
            file = RandomAccessFile(fileName, "r")
            fileLen = file!!.length().toInt()
            bufLen = min(fileLen, MAX_BUFFER_LENGTH)
            buf = ByteArray(bufLen)
            bufStart = Int.MAX_VALUE // nothing in buffer so far
            if (fileLen > 0) setPos(0) // setup buffer to position 0 (start)
            else bufPos = 0 // index 0 is already after the file, thus setPos(0) is invalid
            if (bufLen == fileLen) Close()
        } catch (e: IOException) {
            throw FatalError("Could not open file $fileName")
        }
    }

    // don't use b after this call anymore
    // called in UTF8Buffer constructor
    protected constructor(b: Buffer) {
        buf = b.buf
        bufStart = b.bufStart
        bufLen = b.bufLen
        fileLen = b.fileLen
        bufPos = b.bufPos
        file = b.file
        stream = b.stream
        // keep finalize from closing the file
        b.file = null
    }

    @Throws(Throwable::class)
    protected fun finalize() {
        Close()
    }

    protected fun Close() {
        if (file != null) {
            file = try {
                file!!.close()
                null
            } catch (e: IOException) {
                throw FatalError(e.message)
            }
        }
    }

    open fun Read(): Int {
        return if (bufPos < bufLen) {
            buf[bufPos++].toInt() and 0xff // mask out sign bits
        } else if (getPos() < fileLen) {
            setPos(getPos()) // shift buffer start to pos
            buf[bufPos++].toInt() and 0xff // mask out sign bits
        } else if (stream != null && ReadNextStreamChunk() > 0) {
            buf[bufPos++].toInt() and 0xff // mask out sign bits
        } else {
            EOF
        }
    }

    fun Peek(): Int {
        val curPos = getPos()
        val ch = Read()
        setPos(curPos)
        return ch
    }

    // beg .. begin, zero-based, inclusive, in byte
    // end .. end, zero-based, exclusive, in byte
    fun GetString(beg: Int, end: Int): String {
        var len = 0
        val buf = CharArray(end - beg)
        val oldPos = getPos()
        setPos(beg)
        while (getPos() < end) buf[len++] = Read().toChar()
        setPos(oldPos)
        return String(buf, 0, len)
    }// set the position to the end of the file, Pos will return fileLen.// must be swapped in// already in buffer

    // Wanted position is after buffer and the stream
    // is not seek-able e.g. network or console,
    // thus we have to read the stream manually till
    // the wanted position is in sight.
    fun getPos() = bufPos + bufStart
    fun setPos(value: Int) {
        if (value >= fileLen && stream != null) {
            // Wanted position is after buffer and the stream
            // is not seek-able e.g. network or console,
            // thus we have to read the stream manually till
            // the wanted position is in sight.
            @Suppress("ControlFlowWithEmptyBody")
            while (value >= fileLen && ReadNextStreamChunk() > 0) {}
        }
        if (value < 0 || value > fileLen) {
            throw FatalError("buffer out of bounds access, position: $value")
        }
        if (value >= bufStart && value < bufStart + bufLen) { // already in buffer
            bufPos = value - bufStart
        } else if (file != null) { // must be swapped in
            try {
                file!!.seek(value.toLong())
                bufLen = file!!.read(buf)
                bufStart = value
                bufPos = 0
            } catch (e: IOException) {
                throw FatalError(e.message)
            }
        } else {
            // set the position to the end of the file, Pos will return fileLen.
            bufPos = fileLen - bufStart
        }
    }

    // Read the next chunk of bytes from the stream, increases the buffer
    // if needed and updates the fields fileLen and bufLen.
    // Returns the number of bytes read.
    private fun ReadNextStreamChunk(): Int {
        var free = buf.size - bufLen
        if (free == 0) {
            // in the case of a growing input stream
            // we can neither seek in the stream, nor can we
            // foresee the maximum length, thus we must adapt
            // the buffer size on demand.
            val newBuf = ByteArray(bufLen * 2)
            buf.copyInto(newBuf)
            buf = newBuf
            free = bufLen
        }
        val read: Int = try {
            stream!!.read(buf, bufLen, free)
        } catch (ioex: IOException) {
            throw FatalError(ioex.message)
        }
        if (read > 0) {
            bufLen += read
            fileLen = bufLen
            return read
        }
        // end of stream reached
        return 0
    }

    companion object {
        // This Buffer supports the following cases:
        // 1) seekable stream (file)
        //    a) whole stream in buffer
        //    b) part of stream in buffer
        // 2) non seekable stream (network, console)
        const val EOF = Char.MAX_VALUE.toInt() + 1
        private const val MIN_BUFFER_LENGTH = 1024 // 1KB
        private const val MAX_BUFFER_LENGTH = MIN_BUFFER_LENGTH * 64 // 64KB
    }
} //-----------------------------------------------------------------------------------

// UTF8Buffer
//-----------------------------------------------------------------------------------
internal class UTF8Buffer(b: Buffer) : Buffer(b) {
    override fun Read(): Int {
        var ch: Int
        do {
            ch = super.Read()
            // until we find a utf8 start (0xxxxxxx or 11xxxxxx)
        } while (ch >= 128 && ch and 0xC0 != 0xC0 && ch != EOF)
        if (ch < 128 || ch == EOF) {
            // nothing to do, first 127 chars are the same in ascii and utf8
            // 0xxxxxxx or end of file character
        } else if (ch and 0xF0 == 0xF0) {
            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            val c1 = ch and 0x07
            ch = super.Read()
            val c2 = ch and 0x3F
            ch = super.Read()
            val c3 = ch and 0x3F
            ch = super.Read()
            val c4 = ch and 0x3F
            ch = c1 shl 6 or c2 shl 6 or c3 shl 6 or c4
        } else if (ch and 0xE0 == 0xE0) {
            // 1110xxxx 10xxxxxx 10xxxxxx
            val c1 = ch and 0x0F
            ch = super.Read()
            val c2 = ch and 0x3F
            ch = super.Read()
            val c3 = ch and 0x3F
            ch = c1 shl 6 or c2 shl 6 or c3
        } else if (ch and 0xC0 == 0xC0) {
            // 110xxxxx 10xxxxxx
            val c1 = ch and 0x1F
            ch = super.Read()
            val c2 = ch and 0x3F
            ch = c1 shl 6 or c2
        }
        return ch
    }
} //-----------------------------------------------------------------------------------

// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates {
    private class Elem(var key: Int, var `val`: Int) {
        var next: Elem? = null
    }

    private val tab = arrayOfNulls<Elem>(128)
    operator fun set(key: Int, `val`: Int) {
        val e = Elem(key, `val`)
        val k = key % 128
        e.next = tab[k]
        tab[k] = e
    }

    fun state(key: Int): Int {
        var e = tab[key % 128]
        while (e != null && e.key != key) e = e.next
        return e?.`val` ?: 0
    }
} //-----------------------------------------------------------------------------------

// Scanner
//-----------------------------------------------------------------------------------
class Scanner {
    var buffer: Buffer // scanner buffer
    private var t = Token() // current token
    private var ch = 0 // current input character
    private var pos = 0 // byte position of current character
    private var charPos = 0 // position by unicode characters starting with 0
    private var col = 0 // column number of current character
    private var line = 0 // line number of current character
    private var oldEols = 0 // EOLs that appeared in a comment
    private var tokens: Token? = null // list of tokens already peeked (first token is a dummy)
    private var pt: Token? = null // current peek token
    private var tval = CharArray(16) // token text used in NextToken(), dynamically enlarged
    private var tlen = 0 // length of current token
-->declarations
    companion object {
        const val EOL = '\n'
        const val eofSym = 0
        val start = StartStates() // maps initial token character to start state
        val literals = HashMap<Any?, Any?>() // maps literal strings to literal kinds
-->companion

        init {
-->initialization
        }
    }

    constructor(fileName: String) {
        buffer = Buffer(fileName)
        Init()
    }

    constructor(s: InputStream?) {
        buffer = Buffer(s)
        Init()
    }

    private fun Init() {
        pos = -1
        line = 1
        col = 0
        charPos = -1
        oldEols = 0
        NextCh()
        if (ch == 0xEF) { // check optional byte order mark for UTF-8
            NextCh()
            val ch1 = ch
            NextCh()
            val ch2 = ch
            if (ch1 != 0xBB || ch2 != 0xBF) {
                throw FatalError("Illegal byte order mark at start of file")
            }
            buffer = UTF8Buffer(buffer)
            col = 0
            charPos = -1
            NextCh()
        }
        tokens = Token()
        pt = tokens // first token is a dummy
    }

    private fun NextCh() {
        if (oldEols > 0) {
            ch = EOL.toInt()
            oldEols--
        } else {
            pos = buffer.getPos()
            // buffer reads unicode chars, if UTF8 has been detected
            ch = buffer.Read()
            col++
            charPos++
            // replace isolated '\r' by '\n' in order to make
            // eol handling uniform across Windows, Unix and Mac
            if (ch == '\r'.toInt() && buffer.Peek() != '\n'.toInt()) ch = EOL.toInt()
            if (ch == EOL.toInt()) {
                line++
                col = 0
            }
        }
-->casing
    }

    private fun AddCh() {
        if (tlen >= tval.size) {
            val newBuf = CharArray(2 * tval.size)
            tval.copyInto(newBuf)
            tval = newBuf
        }
        if (ch != Buffer.EOF) {
-->casing2
                    NextCh()
        }
    }

-->comments

    private fun CheckLiteral() {
        var value = t.value
-->casing3
        val kind = literals[value]
        if (kind != null) {
            t.kind = (kind as Int).toInt()
        }
    }

    @Suppress("UNUSED_VALUE")
    private fun NextToken(): Token {
        while (ch == ' '.toInt() ||
-->scan1
        ) NextCh()
-->scan2
        var recKind: Int = noSym
        var recEnd = pos
        t = Token()
        t.pos = pos
        t.col = col
        t.line = line
        t.charPos = charPos
        var state = start.state(ch)
        tlen = 0
        AddCh()
        loop@ while (true) {
            when (state) {
                -1 -> {
                    t.kind = eofSym
                    break@loop
                } // NextCh already done 
                0 -> {
                    if (recKind != noSym) {
                        tlen = recEnd - t.pos
                        SetScannerBehindT()
                    }
                    t.kind = recKind
                    break@loop
                }
-->scan3
            }
        }
        t.value = String(tval, 0, tlen)
        return t
    }

    private fun SetScannerBehindT() {
        buffer.setPos(t.pos)
        NextCh()
        line = t.line
        col = t.col
        charPos = t.charPos
        for (i in 0 until tlen) NextCh()
    }

    // get the next token (possibly a token already seen during peeking)
    fun Scan(): Token {
        return if (tokens!!.next == null) {
            NextToken()
        } else {
            tokens = tokens!!.next
            pt = tokens
            tokens!!
        }
    }

    // get the next token, ignore pragmas
    fun Peek(): Token? {
        do {
            if (pt!!.next == null) {
                pt!!.next = NextToken()
            }
            pt = pt!!.next
        } while (pt!!.kind > maxT) // skip pragmas
        return pt
    }

    // make sure that peeking starts at current scan position
    fun ResetPeek() {
        pt = tokens
    }
} // end Scanner
