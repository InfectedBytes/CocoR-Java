/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University
with additional support for Kotlin by Henrik Heine

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin

class Parser(scanner: Scanner) {

    private companion object {
        private const val _T = true
        private const val _x = false
        private const val minErrDist = 2
        private var _set: Array<BooleanArray>? = null
        private val set get() = _set!!
-->constants
-->declarations
    }

    var t = Token() // last recognized token
    var la = Token() // lookahead token
    private var errDist = minErrDist
    var scanner: Scanner
    internal var errors = Errors()

    private fun SynErr(n: Int) {
        if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n)
        errDist = 0
    }

    fun SemErr(msg: String?) {
        if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg)
        errDist = 0
    }

    private fun Get() {
        while (true) {
            t = la
            la = scanner.Scan()
            if (la.kind <= maxT) {
                ++errDist
                break
            }
-->pragmas
                    la = t
        }
    }

    private fun Expect(n: Int) {
        if (la.kind == n) Get() else {
            SynErr(n)
        }
    }

    private fun StartOf(s: Int): Boolean {
        return set[s][la.kind]
    }

    private fun ExpectWeak(n: Int, follow: Int) {
        if (la.kind == n) Get() else {
            SynErr(n)
            while (!StartOf(follow)) Get()
        }
    }

    private fun WeakSeparator(n: Int, syFol: Int, repFol: Int): Boolean {
        var kind: Int = la.kind
        return if (kind == n) {
            Get()
            true
        } else if (StartOf(repFol)) false else {
            SynErr(n)
            while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
                Get()
                kind = la.kind
            }
            StartOf(syFol)
        }
    }

-->productions

    fun Parse() {
        la = Token()
        la.value = ""
        Get()
-->parseRoot
    }

    init {
        if(_set == null) {
            _set = arrayOf(
-->initialization
            )
        }
        this.scanner = scanner
        errors = Errors()
    }
} // end Parser

internal class Errors {
    var count = 0 // number of errors detected
    var errorStream: java.io.PrintStream = System.out // error messages go to this stream
    var errMsgFormat = "-- line %1\$d col %2\$d: %3\$s\n" // 1=line, 2=column, 3=text
    protected fun printMsg(line: Int, column: Int, msg: String?) {
        errorStream.printf(errMsgFormat, line, column, msg)
    }

    fun SynErr(line: Int, col: Int, n: Int) {
        val s: String = when (n) {
-->errors
            else -> "error $n"
        }
        printMsg(line, col, s)
        count++
    }

    fun SemErr(line: Int, col: Int, s: String?) {
        printMsg(line, col, s)
        count++
    }

    fun SemErr(s: String?) {
        errorStream.println(s)
        count++
    }

    fun Warning(line: Int, col: Int, s: String?) {
        printMsg(line, col, s)
    }

    fun Warning(s: String?) {
        errorStream.println(s)
    }
} // Errors

internal class FatalError(s: String?) : RuntimeException(s) {
    companion object {
        const val serialVersionUID = 1L
    }
}